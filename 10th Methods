METHODS 
What are methods: 
➢ Methods	are	members	of	classes	which	provide	functionality	for	
classes.	
➢ We	can	write	our	own	methods	in	the	classes.	
➢ The	functions	performing	on	the	data	are	known	as	methods.	
➢ When	a	method	returns	a	value	then	the	method	itself	takes	the	
value.	
➢ A	method	will	have	its	own	copy	of	variable.	


➢ Skeleton	of	method:	
returnType	methodName(parameter	list)		!signature/header	
{	
				--------------	
				--------------	
}	




Example	program:

class test 
{ 
 int max(int x, int y)    //non static variables doesnt accept static variables, so we have to make it as static method.
 { 
 if(x>y) 
 return x; 
 else 
 return y; 
 } 
 public static void main(String args[]) 
 { 
 int a=10,b=15,c; 
 c=max(a,b); 
 System.out.println(c); 
 } 
}

//(or) Another way is without writing static keyword for instance method, we can create object creation for that particular class on main()

class test 
{ 
 int max(int x, int y)    
 { 
 if(x>y) 
 return x; 
 else 
 return y; 
 } 
 public static void main(String args[]) 
 { 
 int a=10,b=15,c; 
 
 test t=new test();
 System.out.println(t.max(a,b)); 
 } 
}










Example	program:

class test 
{ 
 static int max(int x, int y)   //(formal parameters)
 { 
 if(x>y) 
 return x; 
 else 
 return y; 
 } 
 public static void main(String args[]) 
 { 
 int a=10,b=15,c; 
 c=max(a,b);                     // //(actual parameters)
 System.out.println(c); 
 
 //System.out.println(max(c)); 
 } 
}


// when a method is called the actual parameter values will pass into formal parameters, and the formal parameters will just have the copy & if any modifications are done to formal parameters it doesnt effect actual parameter variable values.




Example	program:

class test 
{ 
 static int max(int x, int y) 
 { 
 x++; 
 if(x>y) 
 return x; 
 else 
 return y; 
 } 
 public static void main(String args[]) 
 { 
 int a=10,b=15,c; 
 c=max(a,b); 
 System.out.println(c); 
 System.out.println(a);   // the value of a will not be incremented becz its local of main method(the copy only be sended to called method the changes what ever happen in called method it wont reflect again in calling mehtod)
 
 } 
}









Passing object as parameters: 
➢ To	call	a	method	from	main	method	it	is	needed	to	be	maid	static.	
➢ When	the	method	is	called	the	value	of	actual	parameters	are	copied	
in	formal	parameters	which	is	the	only	parameter	passing	method	in	
java.	
➢ The	address	of	object	in	formal	and	actual	parameter	is	Same.	
➢ String	cannot	be	modiIied	as	it	is	immutable.	
➢ A	method	can	also	return	an	object.	
Example	program:	
➢ A	method	can	have	its	object	as	the	return	type.	
Parameter passing in java. 
➢ Whoever	is	calling	a	method	is	called	as	a	caller	or	a	method	call.	
➢ The	method	which	is	called	by	a	caller	is	known	as	called	method.	
➢ The	parameters/arguments	passed	in	calling	method	are	called	as	
actual	parameters.	
class test 
{ 
 static void update(int A[]) 
 { 
 A[0]=25; 
 } 
 public static void main(String args[]) 
 { 
 int A[]={2,3,4,5,6}; 
 update(A); 
 System.out.println(A[0]); 
 } 
}



A	method	can	have	its	object	as	the	return	type.	
Parameter passing in java. 
➢ Whoever	is	calling	a	method	is	called	as	a	caller	or	a	method	call.	
➢ The	method	which	is	called	by	a	caller	is	known	as	called	method.	
➢ The	parameters/arguments	passed	in	calling	method	are	called	as	
actual	parameters.	
➢ And	the	parameters	of	a	called	method	are	called	as	formal	
parameters.	
➢ Formal	parameters	are	nothing	but	input	into	a	method	where	the	
return	type	is	known	as	output	to	a	method.	
➢ The	contents	of	actual	parameters	are	copied	in	formal	parameters	is	
the	only	method	of	parameter	passing	in	java.	
➢ Passing	of	objects	also	follow	the	same	method.	
➢ Parameter	passing	for	primitive	datatypes	the	values	are	copied	in	
formal	parameters,	whereas	in	parameter	passing	of	objects	the	
reference	of	the	object	id	is	copied	in	formal	parameters.	
➢ In	short	the	primitive	datatypes	are	passed	by	value	and	the	objects	
are	passed	by	reference.	


Example	program:

class test 
{ 
 int add(int x, int y) 
 { 
 int z; 
 z=x+y; 
 return z; 
 } 
 public static void main(String args[]) 
 { 
 int a=10,b=5,c; 
 c=add(a,b); 
 System.out.prinlt(c); 
 } 
}



Method overloading: 
➢ Method	overloading	means	writing	more	than	one	method	having	
same	names	but	different	parameter	list	or	data	types.

Compiler	will	call	the	corresponding	method	depending	upon	the	
parameter	list.	
Variable arguments: 
➢ It	is	nothing	but	writing	a	single	method	which	can	run	for	number	of	
parameters	of	same	data	types.	
➢ For	example	–	void	show(int	…x)		
Where	…	represents	the	variable	arguments.	
➢ It	is	similar	to	ellipsis	in	c/c++.	
➢ The	parameters	passed	are	converted	into	an	array.	
➢ The	parameters	can	be	directly	passed	using	an	anonymous	array

➢ Variable	argument	should	always	be	the	last	parameter.	
➢ Printf	is	based	on	variable	arguments	in	version	1.7	java.	
Command line arguments: 
➢ Java	programs	can	utilize	command	line	arguments.	
➢ Dos	Iile	is	used	for	command	line	arguments.	
➢ There	are	different	commands	like.	
• cls:	to	clear	the	screen.	
• dir	:	to	display	the	contents	of	the	disk.	
• cd	windows	:	to	change	the	directory.	
➢ C:	\Windows>	dir	v*.*	
• the	above	is	command	line	in	which	
			Dir	is	command	and	v*.*	is	an	argument
      
RECURSION 
➢ A	recursive	method	is	the	one	which	will	call	itself.	
➢ When	the	recursive	function	can	not	call	itself	further	because	of	the	
base	condition	it	will	return	back	along	the	same	path.	
➢ Not	to	make	the	program	lengthy	loops	are	used	instead	of	recursive	
functions.	
➢ The	recursions	are	used	in	problem	solving.





writing methods:

package methodpractice;


public class MethodPractice {
    
    /*static int max(int x,int y)
    {
        if(x>y)
            return x;
        else 
            return y;
    }*/
    
    static void inc(int x)
    {
        x++;
        System.out.println(x);
    }
    
    public static void main(String[] args) {
    
        /*int a=10,b=15;
        //System.out.println(max(a,b));
        
        MethodPractice mp=new MethodPractice();
        System.out.println(mp.max(a,b));*/
        
        int a=10,b=15;
        inc(a);
        System.out.println(a);
        
        
    }
    }
    



=====================================

practicing Object Passing:


package methodpractice1;

public class MethodPractice1 {

    static void change(int A[],int index,int value)
    {
        A[index]=value;
    }
    
    static void change2(int x,int value)
    {
        x=value;
    }
    
    public static void main(String[] args) {
        int A[]={2,4,6,8,10};
        
        change(A,2,20);
        
        for(int x:A)
        {
            System.out.println(x);
        }
        
        int x=10;
        
        change2(x,20);
        
        System.out.println("Value of primitive"+x);
    }
    
}



=====================================

find a prime number

package scmethod1;

public class SCMethod1 
{
    
     int gcd(int m,int n)
    {
        while(m!=n)
        {
            if(m>n)m=m-n;
            else n=n-m;
        }
        return m;
    }
            
    public static void main(String[] args) 
    {
        SCMethod1 x=new SCMethod1();
        System.out.println(x.gcd(35,56));
        
        
        
        
    } 
        
        
    static boolean isPrime(int n)
    {
        for(int i=2;i<n/2;i++)
        {
            if(n%i==0)
                return false;
        }
        return true;
        
    }

}


=======================================================

// practicing method overloading

package overloading;

class Test
{
    public int max(int a,int b)
    {
        return a>b?a:b;
    }
    
    public int max(int a,int b,int c)
    {
        if(a>b && a>c) return a;
        else if(b>c) return b;
        return c;
    }
}

public class Overloading 
{
    public static void main(String[] args) 
    {
        Test t=new Test();
        t.max(10,5);
        t.max(10,15,5);
        
        
        
    }
    
}




========================================


//overload validate methods



package scmethod2;

public class SCMethod2 
{
    
    
    boolean validate(String name)
    {
        return name.matches("[a-zA-Z\\s]+");
    }
    
    
    boolean validate(int age)
    {
        return age>=3 && age<=15;
    }
    
    
    int reverse(int n)
    {
        int rev=0;
        
        while(n>0)
        {
            rev=rev*10+n%10;
            n=n/10;
        }
        return rev;
    }
    
    
    int [] reverse(int A[])
    {
        int B[]=new int[A.length];
        
        for(int i=A.length-1,j=0;i>=0;i--,j++)
            B[j]=A[i];
        
        return B;
    }
    
    public static void main(String[] args) 
    {
        
    } 
    
    
    
    
    static double area(double radius)
    {
        return Math.PI*radius*radius;
    }
    
    static double area(double length,double breadth)
    {
        return length*breadth;
    }
    
      
}

//===================================================

practicing variable arguments 

package methodpractice;


public class MethodPractice {
    
    /*static int max(int x,int y)
    {
        if(x>y)
            return x;
        else 
            return y;
    }*/
    
    static void inc(int x)
    {
        x++;
        System.out.println(x);
    }
    
    public static void main(String[] args) {
    
        /*int a=10,b=15;
        //System.out.println(max(a,b));
        
        MethodPractice mp=new MethodPractice();
        System.out.println(mp.max(a,b));*/
        
        int a=10,b=15;
        inc(a);
        System.out.println(a);
        
        
    }
    }
    
    
    
//===================================================

//practicing  - variable arguments


package scmethod3;

public class SCMethod3 
{
    static int max(int ...A)
    {
        if(A.length==0)return Integer.MIN_VALUE;
        int max=A[0];
        for(int i=1;i<A.length;i++)
            if(A[i]>max)max=A[i];
        
        return max;
        
    }
    
    static int sum(int ...A)
    {
        int s=0;
        for(int i=0;i<A.length;i++)
            s+=A[i];
        
        return s;
    }
    
    static double sum(double ...P)
    {
        double sum=0;
        
        for(int i=0;i<P.length;i++)
            sum+=P[i];
        
        if(sum<500) return sum*0.10;
        else if(sum>=500 && sum<1000) return sum*0.15;
        else return sum*0.20;
        
    }
    
    
    public static void main(String[] args) 
    {
        System.out.println(max());
        System.out.println(max(10));
        System.out.println(max(10,20));
        System.out.println(max(10,20,30));

    }    
}


//================================================

// calculate discount


package scmethod3;

public class SCMethod3 
{
    static int max(int ...A)
    {
        if(A.length==0)return Integer.MIN_VALUE;
        int max=A[0];
        for(int i=1;i<A.length;i++)
            if(A[i]>max)max=A[i];
        
        return max;
        
    }
    
    static int sum(int ...A)
    {
        int s=0;
        for(int i=0;i<A.length;i++)
            s+=A[i];
        
        return s;
    }
    
    static double sum(double ...P)
    {
        double sum=0;
        
        for(int i=0;i<P.length;i++)
            sum+=P[i];
        
        if(sum<500) return sum*0.10;
        else if(sum>=500 && sum<1000) return sum*0.15;
        else return sum*0.20;
        
    }
    
    
    public static void main(String[] args) 
    {
        System.out.println(max());
        System.out.println(max(10));
        System.out.println(max(10,20));
        System.out.println(max(10,20,30));

    }    
}



//================================================



// program - sum of numbers from command line arguments


package mysum;

public class MySum {

    public static void main(String[] args) {
        double s=0;
        for(String x:args)
        {
            if(x.matches("[0-9\\.]+"))
                s=s+Double.parseDouble(x);
        }
        System.out.println("Sum is "+s);
    }
    
}

//================================================



// program -Recursion

package recursion;

public class Recursion 
{
    static void fun(int n)
    {
        if(n>0)
        {
            fun(n-1);

            System.out.println(n);
        }
    }

    public static void main(String[] args) 
    {
        fun(3);
    }
}


























